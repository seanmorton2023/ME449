final project planning
ME449


Milestone 2


DONE
- find geometry in CoppeliaSim
- implement testing for:
	- GenerateStandoffSE3
	- write_csv_line
	- write_csv_mat
	- EE rotation matrix to object SE3
	


TO-DO
- implement testing for:
	`- convertSE3toJointAngles
	 - jointAnglesStartToEnd
	 - do these by outputting a trajectory to a CSV file and
		having CoppeliaSim run it
- get a sense of scale of what transformation matrices we 
	should expect by manually moving joint sliders and looking for the
	SE3 in CSim, then seeing if plugging it into IKinBody gives
	the same values
		
		
		
		
- make sure the following matrices look good:
	 -
 cuboid_init_SE3_world     
goal_frame_SE3_world       
mobilebase_SE3_init_world  
arm_base_SE3_init_world    
tip_position_SE3_world     

#geometry that's generalized for all configurations of robot
M
R_tip_to_obj =
ee_to_object_SE3 =
ee_at_obj_init_SE3 = 
ee_at_obj_end_SE3 =  
    np.matrix


#geometry for altered scene with the robot closer to the block
arm_base_SE3_init_mod   = mr.RpToTrans(np.identity(3), [0.6722, 0, 9.89E-2])
armbase_to_objectinit_SE3 = np.asarray( \
    np.matrix(mr.TransInv(arm_base_SE3_init_mod)) *  np.matrix(cuboid_init_SE3_world ) )







____

Outline:


1. A trajectory to move the gripper from its initial configuration to a "standoff" configuration a few cm above the block.
2. A trajectory to move the gripper down to the grasp position.
3. Closing of the gripper.
4. A trajectory to move the gripper back up to the "standoff" configuration.
5. A trajectory to move the gripper to a "standoff" configuration above the final configuration.
6. A trajectory to move the gripper to the final configuration of the object.
7. Opening of the gripper.
8. A trajectory to move the gripper back to the "standoff" configuration.


Targets:
- generate standoff position from object initial position
	- same for final position
	- inputs: transformation matrix of object location rel. to. world,
		scalar distance of standoff above part, 
		direction of displacement of standoff
	- operations: applies a translation in the right axis of the object frame
		to produce a transformation matrix for the standoff
	- uses: mr.RpToTrans(R, p), np.identity()
	- returns: a transformation matrix corr. to. standoff
	
	## potential bug ## do error checking to see if the matrix this outputs 
		can be used for other MR programs
	
- generate standoff-to-object trajectory
	- inputs: a transformation matrix for standoff, a transformation matrix
	- already done in CartesianTrajectory
	
- close gripper():
	- could use force control to create a good grip
	- realistically will just maintain motors at a const. torque
	
- open gripper():
	- set motor torque at gripper to 0
	
- convert SE(3) trajectory to joint angles:
	- iterates through a list of trans. matrices and:
		- runs inverse kinematics for the given 
		- stores joint angles in a a list of lists of angles
	- uses:
		- [thetalist,success] = IKinBody(Blist,M,T,thetalist0,eomg,ev)
	- returns the list of joint angles to move through the trajectory
	
	- written, debug
 
 ______
 
 Functions for generating trajectories in each segment of code:
- jointAnglesStartToEnd(Xstart, Xend, Blist, M, thetalist0, eomg, ev):
	- generates a trajectory using CartesianTrajectory()
	- converts to a list of joint angles using convertSE3toJointAngles()
	- returns an array of thetalists
	
First iteration uses the joint angles at the starting config of robot.
Successive iterations use the last joint angles from the previous list
	of joint angles generated

 
- Forward Dynamics:
	- not needed for simulating joint motion in CoppeliaSim as there are 
		no forces in directions that any joint but the gripper
		has to resist motion
	- would be needed if we were running this IRL though

- write to CSV:
	- reuse from last HW
	
	
	
	

Notes
- rotation matrix of tip is wrong; may not matter bc there is no part
	that will move the tip frame relative to the end effector frame
- pad angles with dummy angles if going to use it in scene 6,
	can otherwise use a different scene that doesn't use the mobile base




Questions
- Is there an easy way to convert Tait-Bryan angles from CoppeliaSim
	to rotation matrices? seems important for specifying configuration
	of tip in space
- alternatively, can we tell the robot to send the tip to a location
	in space with arbitrary rotation matrix?
	
	A: don't use the frame in between the prongs of the EE, use the frame
		offset from the tip to plan motion
		
		-> will need to have this one rotated from the end position by a certain angle
			- people usually use either multiples of 45 or 90 degrees








______
end milestone 2