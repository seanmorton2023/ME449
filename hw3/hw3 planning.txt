To-Do: ME449 Asst 3


To-Do: For Submission

Formatting

DONE:

TO-DO:

- organize files: 
	- make "csv" directory and "vid" directory"
	- remove old filenames
	- make "code" directory when done
- put background and helper functions into introduction
- remove comments and unused code
- add docstrings for functions where needed
- put "Part 1", ... markers for each problem
- put text description under each problem as needed
- explanation
	- can be short - my last Jupyter notebook didn't need it

Part 1

DONE:

TO-DO:

- video for dt where energy seems conserved
- video for dt where system seems to gain energy
- csv file for conserved energy
- csv file for increasing energy
- note dt for each case
- note time multipliers used for my own convenience

Part 2

DONE:

TO-DO:

- video for positive damping
- video for negative damping
- csv file for positive damping
- csv file for negative damping
- record values of damping, stiffness, gravity used
- writeup: Do you see any strange behavior in the simulation if you choose the damping constant to
	be a large positive value? Can you explain it? How would this behavior be affected if you chose
	shorter simulation timesteps?

Part 3
- video for zero gravity, no damping
- video for zero gravity, positive damping
- csv file for zero gravity, no damping
- csv file for zero gravity, positive damping
- record values of damping, stiffness, gravity used
- Does the
motion make sense to you? Should total energy be conserved? Does the total energy appear to be
conserved? Do you see any strange behavior if you choose the spring constant to be large?
Now add a positive damping to the simulation that makes the arm nearly come to rest by the
end of the video. For both videos, record the stiffness and damping you used.
 -> could put in video files, or put in notebook somewhere (in notebook would be more 
	modular/easy to edit










Puppet


Values to determine:

Matrices:
- thetalist
- g-vector
- dthetalist
- thetamat (out)
- dthetamat (out)
- Mlist - given
- Slist - given

Scalars:
- t: total sim time
- dt: timestep

Spring params:
- damping
- stiffness
- restLength

	
___

Project Ideation

	Relevant parts of the course text: forward dynamics, 
	inverse dynamics, Newton-Euler recursive dynamics. 
	Look for the formulas that use the M config of each
		joint rel. to. each other
		
	- mr.ForwardDynamics
	- mr.EulerStep
		
	This problem is an: inverse dynamics problem, b/c we 
		know the forces applied at the end effector and
		are trying to find the joint velocities and accelerations
		to get there

________

Steps for doing spring forcing:
- Find current config of end effector
	- find current theta_list
	- apply product of exponentials in space frame, because
		S list given. T = exp([S1]theta1])* ... * M
	- only really need position p so extract that
- Define transformation to get from EE to 
	spring posn, and apply spring force
	Alt 1:
		- I don't like this as much because transformation
			matrices include rotation - we don't want to 
			induce rotation on the E.E.
	- let Tsb be end effector posn, Tsp be spring posn
	- impose that rotation matrix within the spring Tsb
		must be same as the current R of the end effector
	- Tbp = Tbs * Tsp
	- Calculate diff. in p
	- Forces proportional to displacement. Make a wrench
		with Fs = [0, 0, 0, k*deltax, k*deltay, k*deltaz]
		
	Alt 2:
	 - extract position p from Tsb and compare to p from springPosn
	 - difference in p will give a new p-vector
	 - 	Forces proportional to displacement. Make a wrench
		with Fs = [0, 0, 0, k*deltax, k*deltay, k*deltaz]

Part 1: Robot in Gravity
- gravity acting on all the joints of the robot
- simulate wrenches due to:
	- applied forces (0)
	- gravity vector (-g)
	
- Lots of it is already written in the code: solves the
	forward dynamics problem for us, then gives us 
	thetad and thetadd at next timestep
- No "required joint forces" for this part of the HW -
	it's just gravity

-Outline:
	- Call ForwardDynamics() with starting values of thetad,
		thetadd, theta
	- use numerical integration to find theta, thetad at next timestep
		- I don't really like first-order Euler integration. take
			the EulerStep code and modify to include accel term
			in calculating theta
	- store value of theta at next timestep in an array; theta and
		thetad in just a regular variable for next calculation
	- Write the theta_array to a CSV file
	- import the CSV file into CoppeliaSim
	- adjust time multiplier so it takes 5s real time to play file.
		record results for time multiplier.

Part 2: Damping
- Same general loop structure as last time. Copy and paste it in the
	Py file, then fill in with modifications
- Store not just theta and thetad, but also thetadd, for use in
	next iter. of loop
		- for validation: could make sure to store arrays of 
			thetadd and damping force, and make sure force = B * w
- Calculate damping torques and use in tau_list 

Part 3: Spring Force
- same general structure as before, but:
- do not apply damping at first
- calculate spring force according to method above
- use it as the end effector wrench 

- currently p is defined in the space frame; define displacement
	of spring in the body frame instead?
	
- spring forces: although forces are only linear
- check on magnitude of spring displacement in end effector
	frame - distance doesn't seem to be the same - resolved

- try reversing the direction of force - so that robot moves toward the point of interest
	- figure out why later. other people had this too
	
	
results:
- 1.5 through 3 are good
 - 5 is starting to get a little unstable - might be gaining energy
- 8 gives 2 periodic oscillations, and it passes pretty close to the target point. I like it
#used time multiplier of about 3, but at this scale, motions don't appear realistic


#####

Define functions to use here
- Write to csv(): use code from HW2
- ModEulerStep(): modifies EulerStep to 
	have second order term
- Puppet(): 
	- takes in
		- damping stiffness restLength
		- g, Mlist, Glist, Slist (g may be 0 in one sim)
		- thetalist0, dthetalist0
	- calculates
		- end effector wrench Ftip
		- applied joint torques taulist
	- calls 
		- mr.ForwardDynamics(thetalist,dthetalist,taulist,
			g,Ftip,Mlist,Glist,Slist)
		- ModEulerStep(thetalist,dthetalist,ddthetalist,dt)
		- SpringForce()
		- DampingForce()
	- returns: a N x n matrix of joint values, N = # of timesteps,
		n = number of joints

- SpringForce()
	- Calculates the "spring force" acting on the end effector
		of the robot, using position of end of spring, position
		of end effector, and spring parameters.
	- takes in:
		-Slist: list of screw axes in space frame 
		-thetalist: list of current joint angles 
		-Mlist: home configurations of each joint rel. to.
			each other
		-stiffness: scalar with spring constant
		-springPos: 3-vector position 
		-restLength: scalar with resting length of spring
	- calls:
		- T = FKinBody(M_endeff, Blist, thetalist)
		- [R,p] = TranstoRp(FKinBody)
		- x_diff = np.linalg.norm(deltap) - restLength
	- returns:
        Ftip, a 6x1 end-effector wrench caused by the spring force
		
- DampingForce():
	- Make a torque at each joint, equal to B * w
	- takes in:
		- damping constant B
		- thetad_list: an nd-array, where n = # of joints of robot
	- returns:
		- an nd-array of joint torques, where n = # of joints
	- let the required forces for robot to apply be tau_list
		= ****-***** (neg important) * omega_list
	- note to me: other than the forces the robot is applying, robot will be in
		free fall
		

		
	